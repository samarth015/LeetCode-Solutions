#include<bits/stdc++.h>
using namespace std;

// S(abcd) = {{a} + each set of S(bcd)} + S(bcd). Each powerset can be divided into two parts - Where 'a' is 
// included and where 'a' is not included.
class Solution {
public:
    vector<vector<int>> subsets(vector<int>& nums) {
		vector<vector<int>> ss {{}}, nextss;
		for(auto n: nums){
			for(auto s: ss){
				s.push_back(n);
				nextss.push_back(move(s));
			}
			ss.insert(ss.end(), make_move_iterator(nextss.begin()), make_move_iterator(nextss.end()));
			nextss = vector<vector<int>>{};
		}
		return ss;
    }
};

// For each num we can either include it or exclude it from the subset we are generating.
// So we take the decision to include it first then back track to the decision to exclude after
// processing the former decision.
// S(abcd) = {{a} + each set of S(bcd)} + S(bcd). Each powerset can be divided into two parts - Where 'a' is 
// included and where 'a' is not included.
class Solution2 {
	class subSets{
		int n;
		vector<int>& nums; 
		vector<int> comb; 
		vector<vector<int>> res;

		void find(int i){
			if(i == n){
				res.push_back(comb);
				return;
			}

			comb.push_back(nums[i]);
			find(i+1);
			comb.pop_back();
			find(i+1);
		}

		public:
		subSets(vector<int>& nums): n{(int) nums.size()}, nums{nums}, comb{}, res{} {
			comb.reserve(n);
		}

		vector<vector<int>> find(){
			find(0);
			return res;
		}

	};

public:
    vector<vector<int>> subsets(vector<int>& nums) {
		return subSets{nums}.find();
    }
};

// S(abcd|) = {{abcd}} + S(abc|) + S(abd|d) + S(acd|cd) + S(bcd|bcd)
// To avoid duplicates, an unremovable list in maintained. Because S(abc) generates all subsets without 'd'
// other calls will not be allowed to remove 'd' to generate subsets.
// S(abd|d) = {{abd}} + S(ad) + S(bd)    // will not remove 'd' since {ab} was already generated by S(abc)
class Solution3 {
	vector<vector<int>> collector;
	void subsets(unordered_set<int> nums, unordered_set<int> unremovable){
		collector.emplace_back(nums.begin(), nums.end());
		if(nums.size() == 1) return;

		for(auto n: nums){
			if(unremovable.find(n) == unremovable.end()){
				auto reduced = nums;
				reduced.erase(n);
				subsets(move(reduced), unremovable);
				unremovable.insert(n);
			}
		}
	}

public:
    vector<vector<int>> subsets(vector<int>& nums) {
		collector = vector<vector<int>>{{}};
		subsets(unordered_set<int>(nums.begin(), nums.end()), {});
		return collector;
    }
};

int main(){
}

